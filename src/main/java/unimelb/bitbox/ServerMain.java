package unimelb.bitbox;

import java.io.*;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.util.*;
import java.util.concurrent.*;
import java.util.logging.Logger;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import unimelb.bitbox.util.Configuration;
import unimelb.bitbox.util.Document;
import unimelb.bitbox.util.FileSystemManager;
import unimelb.bitbox.util.FileSystemObserver;
import unimelb.bitbox.util.FileSystemManager.FileSystemEvent;

/**
 * A server class which includes several service methods. Mainly used for providing connection service for clients
 * and peers. There are several methods which can be called to check the service status from other classes such as
 * TCPConnection. Example: call addPeer(TCPConnection con) to store a connection (thread) on the server.
 * <p>
 * On the other hand, it is also an observer, which means that it is periodically called by a FileSystemManager thread
 * to broadcast messages generated by observing a folder.
 *
 * @author Zhe Wang
 * @version 1.1 used ThreadPool and CopyOnWriteArrayList for the performance sake
 */

public class ServerMain implements FileSystemObserver {
	private static Logger log = Logger.getLogger(ServerMain.class.getName());
	private static ServerMain server;
	private FileSystemManager fileSystemManager;
	private ThreadPoolExecutor pool;
	private final List<TCPConnection> peerList = new CopyOnWriteArrayList<>();
	private final int poolSize = Integer.parseInt(Configuration.getConfigurationValue("maximumIncommingConnections"));

	private ServerMain() throws NumberFormatException, IOException, NoSuchAlgorithmException {
		fileSystemManager = new FileSystemManager(Configuration.getConfigurationValue("path"), this);
		pool = (ThreadPoolExecutor) Executors.newFixedThreadPool(poolSize);
	}

	public static ServerMain getServerMain() throws IOException, NoSuchAlgorithmException {
		if (server == null) server = new ServerMain();
		return server;
	}

	/**
	 * Overrode from the FileSystemObserver interface
	 * Used for broadcasting message (generated by monitoring the folder)
	 *
	 * @param fileSystemEvent
	 */

	@Override
	public void processFileSystemEvent(FileSystemEvent fileSystemEvent) {
		synchronized (peerList) {
			for (int i = 0; i < peerList.size(); i++) {
				peerList.get(i).pushQueue(fileSystemEvent); //push events into the queue of each connection
			}
		}

	}

	public void tcpListen() throws IOException {
		try {
			ServerSocket listenSocket = new ServerSocket(Integer.parseInt(Configuration.getConfigurationValue("port")));
			while (true) {
				Socket clientSocket = listenSocket.accept();
				log.info("Peer " + clientSocket.getInetAddress().getHostAddress() + ":" + clientSocket.getPort() + " is applying for connection!");
				if(pool.getActiveCount() >= poolSize){
					log.info("MAXIMUM POOL SIZE REACHED, CANNOT ACCEPT MORE");
					Document refuse = new Document();
					refuse.append("command", "CONNECTION_REFUSED");
					refuse.append("message", "connection limit reached");
					refuse.append("peers", this.getPeerList());
					Communication.sendMessage(clientSocket, refuse);
				}
				else{
					synchronized (this){
						pool.submit(new TCPConnection(clientSocket, fileSystemManager, this));
					}
				}
			}
		} catch (IOException e) {
			log.info("Listen : " + e.getMessage());
		}
	}

	/**
	 * connect to the default peers in the configuration file
	 */
	public void tcpInitialConnect() throws IOException {
		String[] defaultPeers = Configuration.getConfigurationValue("peers").split(",");
		for (String peer : defaultPeers) {
			try {
				if(pool.getActiveCount() >= poolSize){
					log.info("MAXIMUM POOL SIZE REACHED, CANNOT CONNECT MORE PEERS");
					continue;
				}
				String[] hostport = peer.split(":");
				Socket socket = new Socket(hostport[0], Integer.parseInt(hostport[1]));
				synchronized (this){
					pool.submit(new TCPConnection(socket, fileSystemManager, this));
				}
				Document command = new Document();
				Document selfHostPort = new Document();
				selfHostPort.append("host", Configuration.getConfigurationValue("advertisedName"));
				selfHostPort.append("port", Integer.parseInt(Configuration.getConfigurationValue("port")));
				command.append("command", "HANDSHAKE_REQUEST");
				command.append("hostPort", selfHostPort);
				Communication.sendMessage(socket, command);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	public void tcpConnect(String host, int port) throws IOException {
		try {
			if(pool.getActiveCount() >= poolSize){
				log.info("MAXIMUM POOL SIZE REACHED, CANNOT CONNECT MORE PEERS");
				return;
			}
			Socket socket = new Socket(host, port);
			synchronized (this){
				pool.submit(new TCPConnection(socket, fileSystemManager, this));
			}
			Document command = new Document();
			Document selfHostPort = new Document();
			selfHostPort.append("host", Configuration.getConfigurationValue("advertisedName"));
			selfHostPort.append("port", Integer.parseInt(Configuration.getConfigurationValue("port")));
			command.append("command", "HANDSHAKE_REQUEST");
			command.append("hostPort", selfHostPort);
			Communication.sendMessage(socket, command);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public boolean addPeer(TCPConnection con) {
		synchronized (peerList) {
			if (peerList.size() < Integer.parseInt(Configuration.getConfigurationValue("maximumIncommingConnections"))) {
				peerList.add(con);
				return true;
			}

		}
		return false;
	}


	/**
	 * check if the connection (thread) calling the method is duplicate, if so then kill it
	 */
	public boolean duplicateHandShake(String ip, int port) {
		for (TCPConnection con : peerList) {
			if (con.getClientInfo()[0].equals(ip) && Integer.parseInt(con.getClientInfo()[1]) == port) {
				return true;
			}
		}
		return false;
	}

	public void removePeer(TCPConnection con) {
		peerList.remove(con);
	}

	public int getConNum() {
		return peerList.size();
	}

	/**
	 * return the peerlist as a list of json by using the client_info provided by the client (their advertised name
	 * and port)
	 *
	 * @return peerlist
	 */
	public ArrayList<Document> getPeerList() {
		ArrayList<Document> peer_array = new ArrayList<>();
		for (TCPConnection con : peerList) {
			Document hostport = new Document();
			hostport.append("host", con.getClientInfo()[2]);
			hostport.append("port", con.getClientInfo()[3]);
			peer_array.add(hostport);
		}
		return peer_array;
	}

	public boolean checkPeerList(String host, int port) {
		for (TCPConnection con : peerList) {
			if (con.getClientInfo()[0].equals(host) && Integer.parseInt(con.getClientInfo()[1]) == port)
				return true;
		}
		return false;
	}

	public boolean quitTCPCon(String host, int port) {
		for (TCPConnection con : peerList) {
			if (con.getClientInfo()[0].equals(host) && Integer.parseInt(con.getClientInfo()[3]) == port) {
				con.setQuit();
				return true;
			}
		}
		return false;
	}

	/**
	 * A inner class which extends Thread. Used for synchronizing events between fixed intervals.
	 */
	public class TCPSyncEvent extends Thread {
		@Override
		public void run() {
			while (true) {
				try {
					while (getConNum() == 0) {
						//wait for connections to generateSyncEvents
					}
					List<FileSystemEvent> sync_list = fileSystemManager.generateSyncEvents();
					for (int i = 0; i < sync_list.size(); i++) {
						processFileSystemEvent(sync_list.get(i));
					}
					if (sync_list.size() == 0) {
						synchronized (peerList) {
							for (int i = 0; i < peerList.size(); i++) {
								peerList.get(i).checkConnectionStatus();
							}
						}

					}
					sleep(1000 * Integer.parseInt(Configuration.getConfigurationValue("syncInterval")));
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
	}


	///////////////
	//ServeClient//
	///////////////

	/**
	 * A inner class used for handling connections from a client
	 */
	public class ServeClient implements Runnable {
		private Logger log = Logger.getLogger(ServeClient.class.getName());
		private final String aeskey = "5v8y/B?D(G+KbPeS";
		private Map<String, String> rsaKeymap;
		private Communication comm;

		public ServeClient() {
			//generate keymap
			rsaKeymap = new HashMap<>();
			String[] keys = Configuration.getConfigurationValue("authorized_keys").split("\n");
			for (String key : keys) {
				String[] split_key = key.split(" ");
				for (int i = 0; i < split_key.length; i++) {
					if (split_key[i].startsWith("AAAA") && i < split_key.length - 1) {
						rsaKeymap.put(split_key[i + 1], split_key[i]);
						break;
					}
				}
			}
		}

		public void run() {
			try {
				ServerSocket listen_socket = new ServerSocket(Integer.parseInt(Configuration.getConfigurationValue("clientPort")));
				while (true) {
					try {
						Socket client_socket = listen_socket.accept();
						log.info("Client " + client_socket.getInetAddress().getHostAddress() + ":" + client_socket.getPort() + " is applying for connection!");
						boolean release = true;
						comm = new Communication(client_socket);
						Document message = Document.parse(comm.readString());
						if (message.getString("command") != null && message.getString("command").equals("AUTH_REQUEST") && message.containsKey("identity")) {
							Document response = new Document();
							response.append("command", "AUTH_RESPONSE");
							String public_key = rsaKeymap.get(message.getString("identity"));
							if (public_key != null) {
								//encrypt the aes key with the client's public key
								AuthorizedKeysDecoder decoder = new AuthorizedKeysDecoder();
								PublicKey key = decoder.decodePublicKey(public_key);
								Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
								cipher.init(Cipher.ENCRYPT_MODE, key);
								response.append("AES128", Base64.getEncoder().encodeToString(cipher.doFinal(aeskey.getBytes("UTF-8"))));
								response.append("status", true);
								response.append("message", "public key found");
								release = false; //found public key, ready to receive payload
							} else {
								response.append("status", false);
								response.append("message", "public key not found");
							}
							comm.sendMessage(response);
						}
						while (!release) {
							message = Document.parse(comm.readString());
							if (message.getString("payload") != null) {
								String payload = message.getString("payload");
								Key key = new SecretKeySpec(aeskey.getBytes("UTF-8"), "AES");
								Cipher cipher = Cipher.getInstance("AES/ECB/NoPadding");
								cipher.init(Cipher.DECRYPT_MODE, key);
								Document decrypted_payload = Document.parse(new String(cipher.doFinal(Base64.getDecoder().decode(payload.getBytes("UTF-8")))).split("\n")[0]);
								if (decrypted_payload.containsKey("command")) {
									Document response = new Document();
									switch (decrypted_payload.getString("command")) {
										case "LIST_PEERS_REQUEST":
											ArrayList<Document> peers;
											peers = getPeerList();
											response.append("command", "LIST_PEERS_RESPONSE");
											response.append("peers", peers);
											Document final_response = new Document();
											final_response.append("payload", encryptPayload(response.toJson()));
											comm.sendMessage(final_response);
											release = true; //sending response and release the connection
											break;

										case "CONNECT_PEER_REQUEST":
											if (!decrypted_payload.containsKey("host") || !decrypted_payload.containsKey("port"))
												break;
											tcpConnect(decrypted_payload.getString("host"), (int) decrypted_payload.getLong("port"));
											response.append("command", "CONNECT_PEER_RESPONSE");
											response.append("host", decrypted_payload.getString("host"));
											response.append("port", decrypted_payload.getLong("port"));
											boolean success = false;
											try {
												String client_ip = InetAddress.getByName(decrypted_payload.getString("host")).getHostAddress();
												long starttime = System.currentTimeMillis();
												//if the connection is established within the timeout
												while (System.currentTimeMillis() - starttime < 2 * 1000 * Integer.parseInt(Configuration.getConfigurationValue("timeout"))) {
													if (checkPeerList(client_ip, (int) decrypted_payload.getLong("port"))) {
														success = true;
														break;
													}

													int random_time = ThreadLocalRandom.current().nextInt(100, 1000);
													Thread.sleep(random_time);
												}
											} catch (InterruptedException | UnknownHostException e) {
												e.printStackTrace();
											}
											if (success) {
												response.append("status", true);
												response.append("message", "connect successful");
											} else {
												response.append("status", false);
												response.append("message", "connect failed");
											}
											final_response = new Document();
											final_response.append("payload", encryptPayload(response.toJson()));
											comm.sendMessage(final_response);
											release = true;
											break;

										case "DISCONNECT_PEER_REQUEST":
											if (!decrypted_payload.containsKey("host") || !decrypted_payload.containsKey("port"))
												break;
											response.append("command", "DISCONNECT_PEER_RESPONSE");
											response.append("host", decrypted_payload.getString("host"));
											response.append("port", decrypted_payload.getLong("port"));
											success = false;
											try {
												String client_ip = InetAddress.getByName(decrypted_payload.getString("host")).getHostAddress();
												if (quitTCPCon(client_ip, (int) decrypted_payload.getLong("port")))
													success = true;
											} catch (UnknownHostException e) {
												e.printStackTrace();
											}
											if (success) {
												response.append("status", true);
												response.append("message", "disconnected from peer");
											} else {
												response.append("status", false);
												response.append("message", "connection not active");
											}
											final_response = new Document();
											final_response.append("payload", encryptPayload(response.toJson()));
											comm.sendMessage(final_response);
											release = true;
											break;
									}
								}
							}
						}
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			} catch (NumberFormatException | IOException e) {
				e.printStackTrace();
			}
		}

		private String encryptPayload(String msg) {
			String message = null;
			try {
				Key key = new SecretKeySpec(aeskey.getBytes("UTF-8"), "AES");
				Cipher cipher = Cipher.getInstance("AES/ECB/NoPadding");
				cipher.init(Cipher.ENCRYPT_MODE, key);
				msg = msg + "\n";
				byte[] content = msg.getBytes("UTF-8");
				int length = 16 - content.length % 16;
				byte[] random = new byte[length];
				byte[] padded = new byte[content.length + length];
				SecureRandom secran = new SecureRandom();
				secran.nextBytes(random);
				System.arraycopy(content, 0, padded, 0, content.length);
				System.arraycopy(random, 0, padded, content.length, random.length);
				message = Base64.getEncoder().encodeToString(cipher.doFinal(padded));
			} catch (Exception e) {
				e.printStackTrace();
			}
			return message;
		}
	}
}